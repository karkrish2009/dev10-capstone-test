{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nimport { fromObject, scale, transform, translate } from 'transformation-matrix';\nimport { ACTION_ZOOM, MODE_IDLE, MODE_ZOOMING, ALIGN_CENTER, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_TOP, ALIGN_BOTTOM, ALIGN_COVER } from '../constants';\nimport { decompose, getSVGPoint, set } from './common';\nimport calculateBox from '../utils/calculateBox';\nexport function isZoomLevelGoingOutOfBounds(value, scaleFactor) {\n  var _decompose = decompose(value),\n    curScaleFactor = _decompose.scaleFactor;\n  var lessThanScaleFactorMin = value.scaleFactorMin && curScaleFactor * scaleFactor < value.scaleFactorMin;\n  var moreThanScaleFactorMax = value.scaleFactorMax && curScaleFactor * scaleFactor > value.scaleFactorMax;\n  return lessThanScaleFactorMin && scaleFactor < 1 || moreThanScaleFactorMax && scaleFactor > 1;\n}\nexport function limitZoomLevel(value, matrix) {\n  var scaleLevel = matrix.a;\n  if (value.scaleFactorMin != null) {\n    // limit minimum zoom\n    scaleLevel = Math.max(scaleLevel, value.scaleFactorMin);\n  }\n  if (value.scaleFactorMax != null) {\n    // limit maximum zoom\n    scaleLevel = Math.min(scaleLevel, value.scaleFactorMax);\n  }\n  return set(matrix, {\n    a: scaleLevel,\n    d: scaleLevel\n  });\n}\nexport function zoom(value, SVGPointX, SVGPointY, scaleFactor) {\n  if (isZoomLevelGoingOutOfBounds(value, scaleFactor)) {\n    // Do not change translation and scale of value\n    return value;\n  }\n  var matrix = transform(fromObject(value), translate(SVGPointX, SVGPointY), scale(scaleFactor, scaleFactor), translate(-SVGPointX, -SVGPointY));\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, matrix), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\n\n//ENHANCEMENT: add ability to control alignment\n//ENHANCEMENT: add ability to selectively fit image inside viewer\n//ENHANCEMENT: refactor some logic in order to merge with fitToViewer function\nexport function fitSelection(value, selectionSVGPointX, selectionSVGPointY, selectionWidth, selectionHeight) {\n  var viewerWidth = value.viewerWidth,\n    viewerHeight = value.viewerHeight;\n  var scaleX = viewerWidth / selectionWidth;\n  var scaleY = viewerHeight / selectionHeight;\n  var scaleLevel = Math.min(scaleX, scaleY);\n  var matrix = transform(scale(scaleLevel, scaleLevel),\n  //2\n  translate(-selectionSVGPointX, -selectionSVGPointY) //1\n  );\n\n  if (isZoomLevelGoingOutOfBounds(value, scaleLevel / value.d)) {\n    // Do not allow scale and translation\n    return set(value, {\n      mode: MODE_IDLE,\n      startX: null,\n      startY: null,\n      endX: null,\n      endY: null\n    });\n  }\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, limitZoomLevel(value, matrix)), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\nexport function fitToViewer(value) {\n  var SVGAlignX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALIGN_LEFT;\n  var SVGAlignY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ALIGN_TOP;\n  var viewerWidth = value.viewerWidth,\n    viewerHeight = value.viewerHeight,\n    SVGMinX = value.SVGMinX,\n    SVGMinY = value.SVGMinY,\n    SVGWidth = value.SVGWidth,\n    SVGHeight = value.SVGHeight;\n  var scaleX = viewerWidth / SVGWidth;\n  var scaleY = viewerHeight / SVGHeight;\n  var scaleLevel = Math.min(scaleX, scaleY);\n  var scaleMatrix = scale(scaleLevel, scaleLevel);\n  var translateX = -SVGMinX * scaleX;\n  var translateY = -SVGMinY * scaleY;\n\n  // after fitting, SVG and the viewer will match in width (1) or in height (2) or SVG will cover the container with preserving aspect ratio (0)\n  if (scaleX < scaleY) {\n    var remainderY = viewerHeight - scaleX * SVGHeight;\n\n    //(1) match in width, meaning scaled SVGHeight <= viewerHeight\n    switch (SVGAlignY) {\n      case ALIGN_TOP:\n        translateY = -SVGMinY * scaleLevel;\n        break;\n      case ALIGN_CENTER:\n        translateY = Math.round(remainderY / 2) - SVGMinY * scaleLevel;\n        break;\n      case ALIGN_BOTTOM:\n        translateY = remainderY - SVGMinY * scaleLevel;\n        break;\n      case ALIGN_COVER:\n        scaleMatrix = scale(scaleY, scaleY); // (0) we must now match to short edge, in this case - height\n        var remainderX = viewerWidth - scaleY * SVGWidth; // calculate remainder in the other scale\n\n        translateX = SVGMinX + Math.round(remainderX / 2); // center by the long edge\n        break;\n      default:\n      //no op\n    }\n  } else {\n    var _remainderX = viewerWidth - scaleY * SVGWidth;\n\n    //(2) match in height, meaning scaled SVGWidth <= viewerWidth\n    switch (SVGAlignX) {\n      case ALIGN_LEFT:\n        translateX = -SVGMinX * scaleLevel;\n        break;\n      case ALIGN_CENTER:\n        translateX = Math.round(_remainderX / 2) - SVGMinX * scaleLevel;\n        break;\n      case ALIGN_RIGHT:\n        translateX = _remainderX - SVGMinX * scaleLevel;\n        break;\n      case ALIGN_COVER:\n        scaleMatrix = scale(scaleX, scaleX); // (0) we must now match to short edge, in this case - width\n        var _remainderY = viewerHeight - scaleX * SVGHeight; // calculate remainder in the other scale\n\n        translateY = SVGMinY + Math.round(_remainderY / 2); // center by the long edge\n        break;\n      default:\n      //no op\n    }\n  }\n\n  var translationMatrix = translate(translateX, translateY);\n  var matrix = transform(translationMatrix,\n  //2\n  scaleMatrix //1\n  );\n\n  if (isZoomLevelGoingOutOfBounds(value, scaleLevel / value.d)) {\n    // Do not allow scale and translation\n    return set(value, {\n      mode: MODE_IDLE,\n      startX: null,\n      startY: null,\n      endX: null,\n      endY: null\n    });\n  }\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, limitZoomLevel(value, matrix)), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\nexport function zoomOnViewerCenter(value, scaleFactor) {\n  var viewerWidth = value.viewerWidth,\n    viewerHeight = value.viewerHeight;\n  var SVGPoint = getSVGPoint(value, viewerWidth / 2, viewerHeight / 2);\n  return zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor);\n}\nexport function startZooming(value, viewerX, viewerY) {\n  return set(value, {\n    mode: MODE_ZOOMING,\n    startX: viewerX,\n    startY: viewerY,\n    endX: viewerX,\n    endY: viewerY\n  });\n}\nexport function updateZooming(value, viewerX, viewerY) {\n  if (value.mode !== MODE_ZOOMING) throw new Error('update selection not allowed in this mode ' + value.mode);\n  return set(value, {\n    endX: viewerX,\n    endY: viewerY\n  });\n}\nexport function stopZooming(value, viewerX, viewerY, scaleFactor) {\n  var TOLERATED_DISTANCE = 7; //minimum distance to choose if area selection or drill down on point\n  var startX = value.startX,\n    startY = value.startY;\n  var start = getSVGPoint(value, startX, startY);\n  var end = getSVGPoint(value, viewerX, viewerY);\n  if (Math.abs(startX - viewerX) > TOLERATED_DISTANCE && Math.abs(startY - viewerY) > TOLERATED_DISTANCE) {\n    var box = calculateBox(start, end);\n    return fitSelection(value, box.x, box.y, box.width, box.height);\n  } else {\n    var SVGPoint = getSVGPoint(value, viewerX, viewerY);\n    return zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor);\n  }\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","value","_toPropertyKey","configurable","writable","arg","_toPrimitive","String","input","hint","prim","toPrimitive","undefined","res","call","TypeError","Number","fromObject","scale","transform","translate","ACTION_ZOOM","MODE_IDLE","MODE_ZOOMING","ALIGN_CENTER","ALIGN_LEFT","ALIGN_RIGHT","ALIGN_TOP","ALIGN_BOTTOM","ALIGN_COVER","decompose","getSVGPoint","set","calculateBox","isZoomLevelGoingOutOfBounds","scaleFactor","_decompose","curScaleFactor","lessThanScaleFactorMin","scaleFactorMin","moreThanScaleFactorMax","scaleFactorMax","limitZoomLevel","matrix","scaleLevel","a","Math","max","min","d","zoom","SVGPointX","SVGPointY","mode","startX","startY","endX","endY","fitSelection","selectionSVGPointX","selectionSVGPointY","selectionWidth","selectionHeight","viewerWidth","viewerHeight","scaleX","scaleY","fitToViewer","SVGAlignX","SVGAlignY","SVGMinX","SVGMinY","SVGWidth","SVGHeight","scaleMatrix","translateX","translateY","remainderY","round","remainderX","_remainderX","_remainderY","translationMatrix","zoomOnViewerCenter","SVGPoint","x","y","startZooming","viewerX","viewerY","updateZooming","Error","stopZooming","TOLERATED_DISTANCE","start","end","abs","box","width","height"],"sources":["C:/Users/karkr/Documents/classes/dev10/testing-tandem/dev10-capstone-test/frontend/node_modules/react-svg-pan-zoom/build-es/features/zoom.js"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { fromObject, scale, transform, translate } from 'transformation-matrix';\nimport { ACTION_ZOOM, MODE_IDLE, MODE_ZOOMING, ALIGN_CENTER, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_TOP, ALIGN_BOTTOM, ALIGN_COVER } from '../constants';\nimport { decompose, getSVGPoint, set } from './common';\nimport calculateBox from '../utils/calculateBox';\nexport function isZoomLevelGoingOutOfBounds(value, scaleFactor) {\n  var _decompose = decompose(value),\n    curScaleFactor = _decompose.scaleFactor;\n  var lessThanScaleFactorMin = value.scaleFactorMin && curScaleFactor * scaleFactor < value.scaleFactorMin;\n  var moreThanScaleFactorMax = value.scaleFactorMax && curScaleFactor * scaleFactor > value.scaleFactorMax;\n  return lessThanScaleFactorMin && scaleFactor < 1 || moreThanScaleFactorMax && scaleFactor > 1;\n}\nexport function limitZoomLevel(value, matrix) {\n  var scaleLevel = matrix.a;\n  if (value.scaleFactorMin != null) {\n    // limit minimum zoom\n    scaleLevel = Math.max(scaleLevel, value.scaleFactorMin);\n  }\n  if (value.scaleFactorMax != null) {\n    // limit maximum zoom\n    scaleLevel = Math.min(scaleLevel, value.scaleFactorMax);\n  }\n  return set(matrix, {\n    a: scaleLevel,\n    d: scaleLevel\n  });\n}\nexport function zoom(value, SVGPointX, SVGPointY, scaleFactor) {\n  if (isZoomLevelGoingOutOfBounds(value, scaleFactor)) {\n    // Do not change translation and scale of value\n    return value;\n  }\n  var matrix = transform(fromObject(value), translate(SVGPointX, SVGPointY), scale(scaleFactor, scaleFactor), translate(-SVGPointX, -SVGPointY));\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, matrix), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\n\n//ENHANCEMENT: add ability to control alignment\n//ENHANCEMENT: add ability to selectively fit image inside viewer\n//ENHANCEMENT: refactor some logic in order to merge with fitToViewer function\nexport function fitSelection(value, selectionSVGPointX, selectionSVGPointY, selectionWidth, selectionHeight) {\n  var viewerWidth = value.viewerWidth,\n    viewerHeight = value.viewerHeight;\n  var scaleX = viewerWidth / selectionWidth;\n  var scaleY = viewerHeight / selectionHeight;\n  var scaleLevel = Math.min(scaleX, scaleY);\n  var matrix = transform(scale(scaleLevel, scaleLevel),\n  //2\n  translate(-selectionSVGPointX, -selectionSVGPointY) //1\n  );\n\n  if (isZoomLevelGoingOutOfBounds(value, scaleLevel / value.d)) {\n    // Do not allow scale and translation\n    return set(value, {\n      mode: MODE_IDLE,\n      startX: null,\n      startY: null,\n      endX: null,\n      endY: null\n    });\n  }\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, limitZoomLevel(value, matrix)), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\nexport function fitToViewer(value) {\n  var SVGAlignX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALIGN_LEFT;\n  var SVGAlignY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ALIGN_TOP;\n  var viewerWidth = value.viewerWidth,\n    viewerHeight = value.viewerHeight,\n    SVGMinX = value.SVGMinX,\n    SVGMinY = value.SVGMinY,\n    SVGWidth = value.SVGWidth,\n    SVGHeight = value.SVGHeight;\n  var scaleX = viewerWidth / SVGWidth;\n  var scaleY = viewerHeight / SVGHeight;\n  var scaleLevel = Math.min(scaleX, scaleY);\n  var scaleMatrix = scale(scaleLevel, scaleLevel);\n  var translateX = -SVGMinX * scaleX;\n  var translateY = -SVGMinY * scaleY;\n\n  // after fitting, SVG and the viewer will match in width (1) or in height (2) or SVG will cover the container with preserving aspect ratio (0)\n  if (scaleX < scaleY) {\n    var remainderY = viewerHeight - scaleX * SVGHeight;\n\n    //(1) match in width, meaning scaled SVGHeight <= viewerHeight\n    switch (SVGAlignY) {\n      case ALIGN_TOP:\n        translateY = -SVGMinY * scaleLevel;\n        break;\n      case ALIGN_CENTER:\n        translateY = Math.round(remainderY / 2) - SVGMinY * scaleLevel;\n        break;\n      case ALIGN_BOTTOM:\n        translateY = remainderY - SVGMinY * scaleLevel;\n        break;\n      case ALIGN_COVER:\n        scaleMatrix = scale(scaleY, scaleY); // (0) we must now match to short edge, in this case - height\n        var remainderX = viewerWidth - scaleY * SVGWidth; // calculate remainder in the other scale\n\n        translateX = SVGMinX + Math.round(remainderX / 2); // center by the long edge\n        break;\n      default:\n      //no op\n    }\n  } else {\n    var _remainderX = viewerWidth - scaleY * SVGWidth;\n\n    //(2) match in height, meaning scaled SVGWidth <= viewerWidth\n    switch (SVGAlignX) {\n      case ALIGN_LEFT:\n        translateX = -SVGMinX * scaleLevel;\n        break;\n      case ALIGN_CENTER:\n        translateX = Math.round(_remainderX / 2) - SVGMinX * scaleLevel;\n        break;\n      case ALIGN_RIGHT:\n        translateX = _remainderX - SVGMinX * scaleLevel;\n        break;\n      case ALIGN_COVER:\n        scaleMatrix = scale(scaleX, scaleX); // (0) we must now match to short edge, in this case - width\n        var _remainderY = viewerHeight - scaleX * SVGHeight; // calculate remainder in the other scale\n\n        translateY = SVGMinY + Math.round(_remainderY / 2); // center by the long edge\n        break;\n      default:\n      //no op\n    }\n  }\n\n  var translationMatrix = translate(translateX, translateY);\n  var matrix = transform(translationMatrix,\n  //2\n  scaleMatrix //1\n  );\n\n  if (isZoomLevelGoingOutOfBounds(value, scaleLevel / value.d)) {\n    // Do not allow scale and translation\n    return set(value, {\n      mode: MODE_IDLE,\n      startX: null,\n      startY: null,\n      endX: null,\n      endY: null\n    });\n  }\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, limitZoomLevel(value, matrix)), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\nexport function zoomOnViewerCenter(value, scaleFactor) {\n  var viewerWidth = value.viewerWidth,\n    viewerHeight = value.viewerHeight;\n  var SVGPoint = getSVGPoint(value, viewerWidth / 2, viewerHeight / 2);\n  return zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor);\n}\nexport function startZooming(value, viewerX, viewerY) {\n  return set(value, {\n    mode: MODE_ZOOMING,\n    startX: viewerX,\n    startY: viewerY,\n    endX: viewerX,\n    endY: viewerY\n  });\n}\nexport function updateZooming(value, viewerX, viewerY) {\n  if (value.mode !== MODE_ZOOMING) throw new Error('update selection not allowed in this mode ' + value.mode);\n  return set(value, {\n    endX: viewerX,\n    endY: viewerY\n  });\n}\nexport function stopZooming(value, viewerX, viewerY, scaleFactor) {\n  var TOLERATED_DISTANCE = 7; //minimum distance to choose if area selection or drill down on point\n  var startX = value.startX,\n    startY = value.startY;\n  var start = getSVGPoint(value, startX, startY);\n  var end = getSVGPoint(value, viewerX, viewerY);\n  if (Math.abs(startX - viewerX) > TOLERATED_DISTANCE && Math.abs(startY - viewerY) > TOLERATED_DISTANCE) {\n    var box = calculateBox(start, end);\n    return fitSelection(value, box.x, box.y, box.width, box.height);\n  } else {\n    var SVGPoint = getSVGPoint(value, viewerX, viewerY);\n    return zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
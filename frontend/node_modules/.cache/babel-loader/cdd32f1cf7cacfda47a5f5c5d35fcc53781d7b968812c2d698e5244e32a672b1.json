{"ast":null,"code":"import { scale } from './scale';\nimport { compose } from './transform';\n/**\r\n * Decompose a matrix into translation, scaling and rotation components, optionally\r\n * take horizontal and vertical flip in to consideration.\r\n * Note this function decomposes a matrix in rotation -> scaling -> translation order. I.e. for\r\n * certain translation T {tx, ty}, rotation R and scaling S { sx, sy }, it's only true for:\r\n *  decomposeTSR(compose(T, S, R)) === { translate: T, rotation: R, scale: S }\r\n * composing in a different order may yield a different decomposition result.\r\n * @param matrix {Matrix} Affine Matrix\r\n * @param  flipX {boolean} Whether the matrix contains vertical flip, i.e. mirrors on x-axis\r\n * @param  flipY {boolean} Whether the matrix contains horizontal flip, i.e. mirrors on y-axis\r\n * @returns {Transform} A transform object consisted by its translation, scaling\r\n * and rotation components.\r\n */\nexport function decomposeTSR(matrix, flipX = false, flipY = false) {\n  // Remove flip from the matrix first - flip could be incorrectly interpreted as\n  // rotations (e.g. flipX + flipY = rotate by 180 degrees).\n  // Note flipX is a vertical flip, and flipY is a horizontal flip.\n  if (flipX) {\n    if (flipY) {\n      matrix = compose(matrix, scale(-1, -1));\n    } else {\n      matrix = compose(matrix, scale(1, -1));\n    }\n  } else if (flipY) {\n    matrix = compose(matrix, scale(-1, 1));\n  }\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  let scaleX, scaleY, rotation;\n  if (a !== 0 || c !== 0) {\n    const hypotAc = Math.hypot(a, c);\n    scaleX = hypotAc;\n    scaleY = (a * d - b * c) / hypotAc;\n    const acos = Math.acos(a / hypotAc);\n    rotation = c > 0 ? -acos : acos;\n  } else if (b !== 0 || d !== 0) {\n    const hypotBd = Math.hypot(b, d);\n    scaleX = (a * d - b * c) / hypotBd;\n    scaleY = hypotBd;\n    const acos = Math.acos(b / hypotBd);\n    rotation = Math.PI / 2 + (d > 0 ? -acos : acos);\n  } else {\n    scaleX = 0;\n    scaleY = 0;\n    rotation = 0;\n  }\n\n  // put the flip factors back\n  if (flipY) {\n    scaleX = -scaleX;\n  }\n  if (flipX) {\n    scaleY = -scaleY;\n  }\n  return {\n    translate: {\n      tx: matrix.e,\n      ty: matrix.f\n    },\n    scale: {\n      sx: scaleX,\n      sy: scaleY\n    },\n    rotation: {\n      angle: rotation\n    }\n  };\n}","map":{"version":3,"names":["scale","compose","decomposeTSR","matrix","flipX","flipY","a","b","c","d","scaleX","scaleY","rotation","hypotAc","Math","hypot","acos","hypotBd","PI","translate","tx","e","ty","f","sx","sy","angle"],"sources":["C:/Users/karkr/Documents/classes/dev10/dev10-capstone/dev10-capstone-test/frontend/node_modules/transformation-matrix/src/decompose.js"],"sourcesContent":["import { scale } from './scale'\r\nimport { compose } from './transform'\r\n/**\r\n * Decompose a matrix into translation, scaling and rotation components, optionally\r\n * take horizontal and vertical flip in to consideration.\r\n * Note this function decomposes a matrix in rotation -> scaling -> translation order. I.e. for\r\n * certain translation T {tx, ty}, rotation R and scaling S { sx, sy }, it's only true for:\r\n *  decomposeTSR(compose(T, S, R)) === { translate: T, rotation: R, scale: S }\r\n * composing in a different order may yield a different decomposition result.\r\n * @param matrix {Matrix} Affine Matrix\r\n * @param  flipX {boolean} Whether the matrix contains vertical flip, i.e. mirrors on x-axis\r\n * @param  flipY {boolean} Whether the matrix contains horizontal flip, i.e. mirrors on y-axis\r\n * @returns {Transform} A transform object consisted by its translation, scaling\r\n * and rotation components.\r\n */\r\nexport function decomposeTSR (matrix, flipX = false, flipY = false) {\r\n  // Remove flip from the matrix first - flip could be incorrectly interpreted as\r\n  // rotations (e.g. flipX + flipY = rotate by 180 degrees).\r\n  // Note flipX is a vertical flip, and flipY is a horizontal flip.\r\n  if (flipX) {\r\n    if (flipY) {\r\n      matrix = compose(matrix, scale(-1, -1))\r\n    } else {\r\n      matrix = compose(matrix, scale(1, -1))\r\n    }\r\n  } else if (flipY) {\r\n    matrix = compose(matrix, scale(-1, 1))\r\n  }\r\n\r\n  const a = matrix.a; const b = matrix.b\r\n  const c = matrix.c; const d = matrix.d\r\n  let scaleX, scaleY, rotation\r\n\r\n  if (a !== 0 || c !== 0) {\r\n    const hypotAc = Math.hypot(a, c)\r\n    scaleX = hypotAc\r\n    scaleY = (a * d - b * c) / hypotAc\r\n    const acos = Math.acos(a / hypotAc)\r\n    rotation = c > 0 ? -acos : acos\r\n  } else if (b !== 0 || d !== 0) {\r\n    const hypotBd = Math.hypot(b, d)\r\n    scaleX = (a * d - b * c) / hypotBd\r\n    scaleY = hypotBd\r\n    const acos = Math.acos(b / hypotBd)\r\n    rotation = Math.PI / 2 + (d > 0 ? -acos : acos)\r\n  } else {\r\n    scaleX = 0\r\n    scaleY = 0\r\n    rotation = 0\r\n  }\r\n\r\n  // put the flip factors back\r\n  if (flipY) {\r\n    scaleX = -scaleX\r\n  }\r\n\r\n  if (flipX) {\r\n    scaleY = -scaleY\r\n  }\r\n\r\n  return {\r\n    translate: { tx: matrix.e, ty: matrix.f },\r\n    scale: { sx: scaleX, sy: scaleY },\r\n    rotation: { angle: rotation }\r\n  }\r\n}\r\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,SAAS;AAC/B,SAASC,OAAO,QAAQ,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAAEC,MAAM,EAAEC,KAAK,GAAG,KAAK,EAAEC,KAAK,GAAG,KAAK,EAAE;EAClE;EACA;EACA;EACA,IAAID,KAAK,EAAE;IACT,IAAIC,KAAK,EAAE;MACTF,MAAM,GAAGF,OAAO,CAACE,MAAM,EAAEH,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACzC,CAAC,MAAM;MACLG,MAAM,GAAGF,OAAO,CAACE,MAAM,EAAEH,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACxC;EACF,CAAC,MAAM,IAAIK,KAAK,EAAE;IAChBF,MAAM,GAAGF,OAAO,CAACE,MAAM,EAAEH,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACxC;EAEA,MAAMM,CAAC,GAAGH,MAAM,CAACG,CAAC;EAAE,MAAMC,CAAC,GAAGJ,MAAM,CAACI,CAAC;EACtC,MAAMC,CAAC,GAAGL,MAAM,CAACK,CAAC;EAAE,MAAMC,CAAC,GAAGN,MAAM,CAACM,CAAC;EACtC,IAAIC,MAAM,EAAEC,MAAM,EAAEC,QAAQ;EAE5B,IAAIN,CAAC,KAAK,CAAC,IAAIE,CAAC,KAAK,CAAC,EAAE;IACtB,MAAMK,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACT,CAAC,EAAEE,CAAC,CAAC;IAChCE,MAAM,GAAGG,OAAO;IAChBF,MAAM,GAAG,CAACL,CAAC,GAAGG,CAAC,GAAGF,CAAC,GAAGC,CAAC,IAAIK,OAAO;IAClC,MAAMG,IAAI,GAAGF,IAAI,CAACE,IAAI,CAACV,CAAC,GAAGO,OAAO,CAAC;IACnCD,QAAQ,GAAGJ,CAAC,GAAG,CAAC,GAAG,CAACQ,IAAI,GAAGA,IAAI;EACjC,CAAC,MAAM,IAAIT,CAAC,KAAK,CAAC,IAAIE,CAAC,KAAK,CAAC,EAAE;IAC7B,MAAMQ,OAAO,GAAGH,IAAI,CAACC,KAAK,CAACR,CAAC,EAAEE,CAAC,CAAC;IAChCC,MAAM,GAAG,CAACJ,CAAC,GAAGG,CAAC,GAAGF,CAAC,GAAGC,CAAC,IAAIS,OAAO;IAClCN,MAAM,GAAGM,OAAO;IAChB,MAAMD,IAAI,GAAGF,IAAI,CAACE,IAAI,CAACT,CAAC,GAAGU,OAAO,CAAC;IACnCL,QAAQ,GAAGE,IAAI,CAACI,EAAE,GAAG,CAAC,IAAIT,CAAC,GAAG,CAAC,GAAG,CAACO,IAAI,GAAGA,IAAI,CAAC;EACjD,CAAC,MAAM;IACLN,MAAM,GAAG,CAAC;IACVC,MAAM,GAAG,CAAC;IACVC,QAAQ,GAAG,CAAC;EACd;;EAEA;EACA,IAAIP,KAAK,EAAE;IACTK,MAAM,GAAG,CAACA,MAAM;EAClB;EAEA,IAAIN,KAAK,EAAE;IACTO,MAAM,GAAG,CAACA,MAAM;EAClB;EAEA,OAAO;IACLQ,SAAS,EAAE;MAAEC,EAAE,EAAEjB,MAAM,CAACkB,CAAC;MAAEC,EAAE,EAAEnB,MAAM,CAACoB;IAAE,CAAC;IACzCvB,KAAK,EAAE;MAAEwB,EAAE,EAAEd,MAAM;MAAEe,EAAE,EAAEd;IAAO,CAAC;IACjCC,QAAQ,EAAE;MAAEc,KAAK,EAAEd;IAAS;EAC9B,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}